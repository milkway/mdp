# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Try to solve MDP with binary exact model
#' @param \code{distanceMatrix} Square and symmetric distance matrix 
#' @param \code{m} Tour size
#' @param \code{MAX_TIME} Its time to stop folks.
#' @param \code{THREADS} Number of threads to be used
#' @param \code{verbose} true or false
#' @return A baby 
#' @examples
#' binarymodel(...)
#' @export 
binarymodel <- function(distances, m, MAX_TIME = 10, THREADS = 4L, verbose = FALSE) {
    .Call(`_mdp_binarymodel`, distances, m, MAX_TIME, THREADS, verbose)
}

#' Best Fitness and solution index of population
#' @param \code{Population} to fit.
#' @param \code{distanceMatrix} Square and symmetric distance matrix 
#' @return A baby 
#' @examples
#' findBestPopFitness()
findBestPopFitness <- function(Population, distanceMatrix) {
    .Call(`_mdp_findBestPopFitness`, Population, distanceMatrix)
}

#' Cross Over between S_a and S_b 
#' @param \code{S_a} Parent A
#' @param \code{S_b} Parent B
#' @param \code{distanceMatrix} Square and symmetric distance matrix 
#' @return A baby 
#' @examples
#' doCrossOver()
doCrossOver <- function(S_a, S_b, distanceMatrix) {
    .Call(`_mdp_doCrossOver`, S_a, S_b, distanceMatrix)
}

#' Backbone Cross Over between S_a and S_b 
#' @param \code{S_a} Parent A
#' @param \code{S_b} Parent B
#' @param  \code{distanceMatrix} Square and symmetric distance matrix 
#' @return A baby 
#' @examples
#' doBackboneCrossOver()
doBackboneCrossOver <- function(S_a, S_b, distanceMatrix) {
    .Call(`_mdp_doBackboneCrossOver`, S_a, S_b, distanceMatrix)
}

#' Execute a Tabu Search in the neighborhood of Solution S (Max Iterations)
#' @param \code{S} initial solution
#' @param \code{distanceMatrix} Square and symmetric distance matrix
#' @return Best solution of local tabu search 
#' @examples
#' dotabuSearch()
doTabuSearchMI <- function(S, distanceMatrix, alpha = 15L, rhoOver2 = 2, maxIterations = 1000L) {
    .Call(`_mdp_doTabuSearchMI`, S, distanceMatrix, alpha, rhoOver2, maxIterations)
}

#' Execute a Tabu Search in the neighborhood of Solution S (Max Losts)
#' @param \code{S} initial solution
#' @param \code{distanceMatrix} Square and symmetric distance matrix
#' @return Best solution of local tabu search 
#' @examples
#' dotabuSearch()
doTabuSearchML <- function(S, distanceMatrix, alpha = 15L, rhoOver2 = 1, lostMaxIterations = 1000L) {
    .Call(`_mdp_doTabuSearchML`, S, distanceMatrix, alpha, rhoOver2, lostMaxIterations)
}

#' MAMDP population update
#' @param \code{S} population candidate
#' @param \code{Population} population to be updated
#' @return New population 
#' @examples
#' updatePopulation()
updatePopulationMAMDP <- function(S, Population, distanceMatrix, beta = 0.6) {
    .Call(`_mdp_updatePopulation`, S, Population, distanceMatrix, beta)
}

#' Rank based pool population update
#' @param \code{S} population candidate
#' @param \code{Population} population to be updated
#' @return New population 
#' @examples
#' updatePopulationByRank()
updatePopulationByRank <- function(S, Population, distanceMatrix, beta = 0.6) {
    .Call(`_mdp_updatePopulationByRank`, S, Population, distanceMatrix, beta)
}

#' Opposition Based Population initialization 
#' @details Get the initial populatio
#' @param \code{TourSize} Well..
#' @param \code{Distances} Distance matrix
#' @param \code{PopulationSize} That's it.
#' @return A matrix where each column is a individual in the population
#' @export 
initializeOPB <- function(distanceMatrix, tourSize, populationSize = 10L, maxIterations = 100L, multiplier = 1L, rhoOver2 = 2) {
    .Call(`_mdp_initializeOBP`, distanceMatrix, tourSize, populationSize, maxIterations, multiplier, rhoOver2)
}

#' Pool Population initialization 
#' @details Get the initial populatio
#' @param \code{tourSize} Ok. Stop it.
#' @param \code{Distances} Distance matrix
#' @param \code{populationSize} You know! 
#' @return A matrix where each column is a individual in the population
#' @export 
initializePool <- function(distanceMatrix, tourSize, populationSize = 10L, maxIterations = 100L, multiplier = 1L, rhoOver2 = 2) {
    .Call(`_mdp_initializePool`, distanceMatrix, tourSize, populationSize, maxIterations, multiplier, rhoOver2)
}

#' Pool Population initialization (Maximum Lost)
#' @details Get the initial populatio
#' @param \code{TourSize} Thats it.
#' @param \code{Distances} Distance matrix
#' @param \code{populationSize} Same old guy 
#' @return A matrix where each column is a individual in the population
#' @export 
initializePoolML <- function(distanceMatrix, tourSize, populationSize = 10L, lostMaxIterations = 100L, multiplier = 1L, rhoOver2 = 2) {
    .Call(`_mdp_initializePoolML`, distanceMatrix, tourSize, populationSize, lostMaxIterations, multiplier, rhoOver2)
}

#' Get fitness from tour
#' @details Get fitness using the tour, m and distance matrix
#' @param \code{Tour} Set of tour's nodes.
#' @param \code{Distances} Distance matrix
#' @return A double value representing the chromosome fitness
#' @export 
getBinaryTourFitness <- function(Tour, distanceMatrix) {
    .Call(`_mdp_getBinaryTourFitness`, Tour, distanceMatrix)
}

#' Get fitness from tour
#' @details Get fitness using the tour, m and distance matrix
#' @param \code{Tour} Set of tour's nodes.
#' @param \code{Distances} Distance matrix
#' @return A double value representing the chromosome fitness
#' @export 
getTourFitness <- function(Tour, distanceMatrix) {
    .Call(`_mdp_getTourFitness`, Tour, distanceMatrix)
}

#' Distance between to individuals;
#' @details Distance between to individuals: m - sum(S0XS1);
#' @param \code{S0} Individual.
#' @param \code{S1} Individual.
#' @return A int, number of moves to go from one individual to the other.
#' @export 
getSolutionsDistance <- function(S0, S1) {
    .Call(`_mdp_getSolutionsDistance`, S0, S1)
}

#' Distance between a individual and a population;
#' @details Distance between to individuals in population: min(m - sum(S0XS), S in Population);
#' @param \code{S0} Individual.
#' @param \code{Population} Target Population.
#' @return A int, min distance between a indivitual and a population.
#' @export 
getSolutionToPopulationDistance <- function(S0, Population) {
    .Call(`_mdp_getSolutionToPopulationDistance`, S0, Population)
}

#' Average distance between a individual and its population;
#' @details Average distance between a individual and other elements in population: mean(m - sum(S0XS), S in Population, S not i);
#' @param \code{S0} Individual.
#' @param \code{Population} Target Population.
#' @return A int, min distance between a indivitual and a population.
#' @export 
getAverageDistanceToPopulation <- function(S0, Population) {
    .Call(`_mdp_getAverageDistanceToPopulation`, S0, Population)
}

#' Average distance between a individual and its population (by index);
#' @details Average distance between a individual and other elements in population: mean(m - sum(S0XS), S in Population, S not i);
#' @param \code{S0} Individual.
#' @param \code{Population} Target Population.
#' @return A int, min distance between a indivitual and a population.
#' @export 
getAverageDistanceToPopulationByIndex <- function(index, Population) {
    .Call(`_mdp_getAverageDistanceToPopulationByIndex`, index, Population)
}

#' Distance between a individual and a population by index;
#' @details Distance between to individuals in population: min(m - sum(S0XS), S in Population);
#' @param \code{S0} Individual.
#' @param \code{Population} Target Population.
#' @return A int, min distance between a indivitual and a population.
#' @export 
getSolutionToPopulationDistanceByIndex <- function(index, Population) {
    .Call(`_mdp_getSolutionToPopulationDistanceByIndex`, index, Population)
}

#' Execute a Tabu Search in the neighborhood of Solution S (Max Iterations)
#' @param \code{S} initial solution
#' @param \code{distanceMatrix} Square and symmetric distance matrix
#' @return Best solution of local tabu search 
#' @examples
#' dotabuSearch()
doTabuSearchParallel <- function(S, distanceMatrix, alpha = 15L, rhoOver2 = 4, maxIterations = 1000L) {
    .Call(`_mdp_doTabuSearchParallel`, S, distanceMatrix, alpha, rhoOver2, maxIterations)
}

#' Pool Population initialization 
#' @details Get the initial populatio
#' @param \code{tourSize} Ok. Stop it.
#' @param \code{Distances} Distance matrix
#' @param \code{populationSize} You know! 
#' @return A matrix where each column is a individual in the population
#' @export 
initializeTiming <- function(distanceMatrix, tourSize, populationSize = 10L, maxIterations = 100L, multiplier = 1L) {
    .Call(`_mdp_initializePoolTiming`, distanceMatrix, tourSize, populationSize, maxIterations, multiplier)
}

#' Hao's Hybrid Metaheuristic method for the Maximum Diversity Problem
#' @details Get over it!
#' @param \code{distanceMatrix} Symmetric matrix.
#' @param \code{tourSize} Subset size of nodes.
#' @param \code{populationSize} Number of individual in population.
#' @param \code{maxIterations} for the tabu search.
#' @return A better person.
#' @export 
mamdp <- function(distanceMatrix, tourSize, populationSize, maxIterations, maxTime = 60, multiplier = 3L, rhoOver2 = 2, verbose = TRUE) {
    .Call(`_mdp_mamdp`, distanceMatrix, tourSize, populationSize, maxIterations, maxTime, multiplier, rhoOver2, verbose)
}

#' Hao's Opposition-based Memetic memetic search for the Maximum Diversity Problem
#' @details Get over it!
#' @param \code{distanceMatrix} Symmetric matrix.
#' @param \code{tourSize} Subset size of nodes.
#' @param \code{populationSize} Number of individual in population.
#' @param \code{maxIterations} for the tabu search.
#' @return A better man.
#' @export 
obma <- function(distanceMatrix, tourSize, populationSize, maxIterations, maxTime = 60, multiplier = 3L, rhoOver2 = 2, verbose = TRUE) {
    .Call(`_mdp_obma`, distanceMatrix, tourSize, populationSize, maxIterations, maxTime, multiplier, rhoOver2, verbose)
}

#' Hao's Diversification-driven Memetic Algorith for Maximum Diversity Problem 
#' @details Get over it!
#' @param \code{distanceMatrix} Symmetric matrix.
#' @param \code{tourSize} Subset size of nodes.
#' @param \code{populationSize} Number of individual in population.
#' @param \code{lostMaxIterations} for the tabu search.
#' @param \code{maxTime} Time limit for execution.
#' @param \code{p} Probability of get laid. Otherwise go fish in random pool.
#' @return A better man.
#' @export 
dmamdp <- function(distanceMatrix, tourSize, populationSize, maxTime, lostMaxIterations, p, multiplier, rhoOver2 = 2, verbose = TRUE) {
    .Call(`_mdp_dmamdp`, distanceMatrix, tourSize, populationSize, maxTime, lostMaxIterations, p, multiplier, rhoOver2, verbose)
}

