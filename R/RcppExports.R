# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Try to solve MDP with binary exact model
#' @param \code{distanceMatrix} Square and symmetric distance matrix 
#' @param \code{m} Tour size
#' @param \code{MAX_TIME} Its time to stop folks.
#' @param \code{THREADS} Number of threads to be used
#' @param \code{verbose} true or false
#' @return A baby 
#' @examples
#' binarymodel(...)
#' @export 
binarymodel <- function(distances, m, MAX_TIME = 10, THREADS = 4L, verbose = FALSE) {
    .Call(`_mdp_binarymodel`, distances, m, MAX_TIME, THREADS, verbose)
}

#' Best Fitness and solution index of population
#' @param \code{Population} to fit.
#' @param \code{distanceMatrix} Square and symmetric distance matrix 
#' @return A baby 
#' @examples
#' findBestPopFitness()
findBestPopFitness <- function(Population, distanceMatrix) {
    .Call(`_mdp_findBestPopFitness`, Population, distanceMatrix)
}

#' Cross Over between S_a and S_b 
#' @param \code{S_a} Parent A
#' @param \code{S_b} Parent B
#' @param \code{distanceMatrix} Square and symmetric distance matrix 
#' @return A baby 
#' @examples
#' doCrossOver()
doCrossOver <- function(S_a, S_b, distanceMatrix) {
    .Call(`_mdp_doCrossOver`, S_a, S_b, distanceMatrix)
}

#' Backbone Cross Over between S_a and S_b 
#' @param \code{S_a} Parent A
#' @param \code{S_b} Parent B
#' @param  \code{distanceMatrix} Square and symmetric distance matrix 
#' @return A baby 
#' @examples
#' doBackboneCrossOver()
doBackboneCrossOver <- function(S_a, S_b, distanceMatrix) {
    .Call(`_mdp_doBackboneCrossOver`, S_a, S_b, distanceMatrix)
}

#' Execute a Tabu Search in the neighborhood of Solution S (Max Iterations)
#' @param \code{S} initial solution
#' @param \code{distanceMatrix} Square and symmetric distance matrix
#' @return Best solution of local tabu search 
#' @examples
#' dotabuSearch()
doTabuSearchMI <- function(S, distanceMatrix, alpha = 15L, rhoOver2 = 2, maxIterations = 1000L) {
    .Call(`_mdp_doTabuSearchMI`, S, distanceMatrix, alpha, rhoOver2, maxIterations)
}

#' Execute a Tabu Search in the neighborhood of Solution S (Max Losts)
#' @param \code{S} initial solution
#' @param \code{distanceMatrix} Square and symmetric distance matrix
#' @return Best solution of local tabu search 
#' @examples
#' dotabuSearch()
doTabuSearchML <- function(S, distanceMatrix, alpha = 15L, rhoOver2 = 1, lostMaxIterations = 1000L) {
    .Call(`_mdp_doTabuSearchML`, S, distanceMatrix, alpha, rhoOver2, lostMaxIterations)
}

#' MAMDP population update
#' @param \code{S} population candidate
#' @param \code{Population} population to be updated
#' @return New population 
#' @examples
#' updatePopulation()
updatePopulationMAMDP <- function(S, Population, distanceMatrix, beta = 0.6) {
    .Call(`_mdp_updatePopulation`, S, Population, distanceMatrix, beta)
}

#' Rank based pool population update
#' @param \code{S} population candidate
#' @param \code{Population} population to be updated
#' @return New population 
#' @examples
#' updatePopulationByRank()
updatePopulationByRank <- function(S, Population, distanceMatrix, beta = 0.6) {
    .Call(`_mdp_updatePopulationByRank`, S, Population, distanceMatrix, beta)
}

#' Opposition Based Population initialization 
#' @details Get the initial populatio
#' @param \code{TourSize} Well..
#' @param \code{Distances} Distance matrix
#' @param \code{PopulationSize} That's it.
#' @return A matrix where each column is a individual in the population
#' @export 
initializeOPB <- function(distanceMatrix, tourSize, populationSize = 10L, maxIterations = 100L, multiplier = 1L, rhoOver2 = 2) {
    .Call(`_mdp_initializeOBP`, distanceMatrix, tourSize, populationSize, maxIterations, multiplier, rhoOver2)
}

#' Pool Population initialization 
#' @details Get the initial populatio
#' @param \code{tourSize} Ok. Stop it.
#' @param \code{Distances} Distance matrix
#' @param \code{populationSize} You know! 
#' @return A matrix where each column is a individual in the population
#' @export 
initializePool <- function(distanceMatrix, tourSize, populationSize = 10L, maxIterations = 100L, multiplier = 1L, rhoOver2 = 2) {
    .Call(`_mdp_initializePool`, distanceMatrix, tourSize, populationSize, maxIterations, multiplier, rhoOver2)
}

#' Pool Population initialization (Maximum Lost)
#' @details Get the initial populatio
#' @param \code{TourSize} Thats it.
#' @param \code{Distances} Distance matrix
#' @param \code{populationSize} Same old guy 
#' @return A matrix where each column is a individual in the population
#' @export 
initializePoolML <- function(distanceMatrix, tourSize, populationSize = 10L, lostMaxIterations = 100L, multiplier = 1L, rhoOver2 = 2) {
    .Call(`_mdp_initializePoolML`, distanceMatrix, tourSize, populationSize, lostMaxIterations, multiplier, rhoOver2)
}

#' Get fitness from tour
#' @details Get fitness using the tour, m and distance matrix
#' @param \code{Tour} Set of tour's nodes.
#' @param \code{Distances} Distance matrix
#' @return A double value representing the chromosome fitness
#' @export 
getBinaryTourFitness <- function(Tour, distanceMatrix) {
    .Call(`_mdp_getBinaryTourFitness`, Tour, distanceMatrix)
}

#' Get fitness from tour
#' @details Get fitness using the tour, m and distance matrix
#' @param \code{Tour} Set of tour's nodes.
#' @param \code{Distances} Distance matrix
#' @return A double value representing the chromosome fitness
#' @export 
getTourFitness <- function(Tour, distanceMatrix) {
    .Call(`_mdp_getTourFitness`, Tour, distanceMatrix)
}

#' Distance between to individuals;
#' @details Distance between to individuals: m - sum(S0XS1);
#' @param \code{S0} Individual.
#' @param \code{S1} Individual.
#' @return A int, number of moves to go from one individual to the other.
#' @export 
getSolutionsDistance <- function(S0, S1) {
    .Call(`_mdp_getSolutionsDistance`, S0, S1)
}

#' Distance between a individual and a population;
#' @details Distance between to individuals in population: min(m - sum(S0XS), S in Population);
#' @param \code{S0} Individual.
#' @param \code{Population} Target Population.
#' @return A int, min distance between a indivitual and a population.
#' @export 
getSolutionToPopulationDistance <- function(S0, Population) {
    .Call(`_mdp_getSolutionToPopulationDistance`, S0, Population)
}

#' Average distance between a individual and its population;
#' @details Average distance between a individual and other elements in population: mean(m - sum(S0XS), S in Population, S not i);
#' @param \code{S0} Individual.
#' @param \code{Population} Target Population.
#' @return A int, min distance between a indivitual and a population.
#' @export 
getAverageDistanceToPopulation <- function(S0, Population) {
    .Call(`_mdp_getAverageDistanceToPopulation`, S0, Population)
}

#' Average distance between a individual and its population (by index);
#' @details Average distance between a individual and other elements in population: mean(m - sum(S0XS), S in Population, S not i);
#' @param \code{S0} Individual.
#' @param \code{Population} Target Population.
#' @return A int, min distance between a indivitual and a population.
#' @export 
getAverageDistanceToPopulationByIndex <- function(index, Population) {
    .Call(`_mdp_getAverageDistanceToPopulationByIndex`, index, Population)
}

#' Distance between a individual and a population by index;
#' @details Distance between to individuals in population: min(m - sum(S0XS), S in Population);
#' @param \code{S0} Individual.
#' @param \code{Population} Target Population.
#' @return A int, min distance between a indivitual and a population.
#' @export 
getSolutionToPopulationDistanceByIndex <- function(index, Population) {
    .Call(`_mdp_getSolutionToPopulationDistanceByIndex`, index, Population)
}

#' Execute a Tabu Search in the neighborhood of Solution S (Max Iterations)
#' @param \code{S} initial solution
#' @param \code{distanceMatrix} Square and symmetric distance matrix
#' @return Best solution of local tabu search 
#' @examples
#' dotabuSearch()
doTabuSearchParallel <- function(S, distanceMatrix, alpha = 15L, rhoOver2 = 4, maxIterations = 1000L) {
    .Call(`_mdp_doTabuSearchParallel`, S, distanceMatrix, alpha, rhoOver2, maxIterations)
}

#' Pool Population initialization 
#' @details Get the initial populatio
#' @param \code{tourSize} Ok. Stop it.
#' @param \code{Distances} Distance matrix
#' @param \code{populationSize} You know! 
#' @return A matrix where each column is a individual in the population
#' @export 
initializeTiming <- function(distanceMatrix, tourSize, populationSize = 10L, maxIterations = 100L, multiplier = 1L) {
    .Call(`_mdp_initializePoolTiming`, distanceMatrix, tourSize, populationSize, maxIterations, multiplier)
}

#' Hao's Hybrid Metaheuristic method for the Maximum Diversity Problem
#' Ref: http://dx.doi.org/10.1016/j.ejor.2013.06.002
#' @details Get over it!
#' @param \code{distances} Symmetric matrix.
#' @param \code{tour_size} Subset size of nodes.
#' @param \code{population_size} Number of individual in population.
#' @param \code{max_iterations} for the tabu search.
#' @param \code{max_time} time limit.
#' @param \code{beta} for update population.
#' @param \code{tabu_rho} for tabu search
#' @param \code{tabu_alpha} for tabu search.
#' @param \code{verbose} well.
#' @return A better person.
#' @export
hao_mamdp <- function(distances, tour_size, population_size = 10L, max_time = 20, beta = .6, population_multiplier = 3L, tabu_max_iterations = 50000L, tabu_rho = 1, tabu_alpha = 15, verbose = FALSE) {
    .Call(`_mdp_hao_mamdp`, distances, tour_size, population_size, max_time, beta, population_multiplier, tabu_max_iterations, tabu_rho, tabu_alpha, verbose)
}

#' Hao's Hybrid Metaheuristic method for the Maximum Diversity Problem
#' @details Get over it!
#' @param \code{distanceMatrix} Symmetric matrix.
#' @param \code{tourSize} Subset size of nodes.
#' @param \code{populationSize} Number of individual in population.
#' @param \code{maxIterations} for the tabu search.
#' @return A better person.
#' @export 
mamdp <- function(distanceMatrix, tourSize, populationSize, maxIterations, maxTime = 60, multiplier = 3L, rhoOver2 = 2, verbose = TRUE) {
    .Call(`_mdp_mamdp`, distanceMatrix, tourSize, populationSize, maxIterations, maxTime, multiplier, rhoOver2, verbose)
}

#' Hao's Opposition-based Memetic memetic search for the Maximum Diversity Problem
#' @details Get over it!
#' @param \code{distanceMatrix} Symmetric matrix.
#' @param \code{tourSize} Subset size of nodes.
#' @param \code{populationSize} Number of individual in population.
#' @param \code{maxIterations} for the tabu search.
#' @return A better man.
#' @export 
obma <- function(distanceMatrix, tourSize, populationSize, maxIterations, maxTime = 60, multiplier = 3L, rhoOver2 = 2, verbose = TRUE) {
    .Call(`_mdp_obma`, distanceMatrix, tourSize, populationSize, maxIterations, maxTime, multiplier, rhoOver2, verbose)
}

#' Hao's Diversification-driven Memetic Algorith for Maximum Diversity Problem 
#' @details Get over it!
#' @param \code{distanceMatrix} Symmetric matrix.
#' @param \code{tourSize} Subset size of nodes.
#' @param \code{populationSize} Number of individual in population.
#' @param \code{lostMaxIterations} for the tabu search.
#' @param \code{maxTime} Time limit for execution.
#' @param \code{p} Probability of get laid. Otherwise go fish in random pool.
#' @return A better man.
#' @export 
dmamdp <- function(distanceMatrix, tourSize, populationSize, maxTime, lostMaxIterations, p, multiplier, rhoOver2 = 2, verbose = TRUE) {
    .Call(`_mdp_dmamdp`, distanceMatrix, tourSize, populationSize, maxTime, lostMaxIterations, p, multiplier, rhoOver2, verbose)
}

#' Execute a Tabu Search in the neighborhood of Solution S (Max Iterations)
#' @param \code{S} Initial solution.
#' @param \code{fitness} Initial solution fitness variable.
#' @param \code{distances} Square and symmetric distance matrix.
#' @param \code{alpha} Tenure list multiplier.
#' @param \code{rho} Neighborhood constraint coefficient.
#' @param \code{max_iteration} number of search iterations.
#' @param \code{verbose} print results
#' @returm int. interation of the best fitness. 
#' @examples
#' cnts()
cnts <- function(S, fitness, distances, alpha = 15L, rho = 1, max_iterations = 1000L, verbose = FALSE) {
    .Call(`_mdp_cnts`, S, fitness, distances, alpha, rho, max_iterations, verbose)
}

#' Execute a Tabu Search in the neighborhood of Solution S (Max Iterations)
#' @param \code{S} Initial solution.
#' @param \code{fitness} Initial solution fitness variable.
#' @param \code{distances} Square and symmetric distance matrix.
#' @param \code{alpha} Tenure list multiplier.
#' @param \code{rho} Neighborhood constraint coefficient.
#' @param \code{max_iteration} number of search iterations.
#' @param \code{verbose} print results
#' @returm int. interation of the best fitness. 
#' @examples
#' cnts()
cnts_sugar <- function(S, distances, alpha = 15L, rho = 1, max_iterations = 1000L, verbose = FALSE) {
    .Call(`_mdp_cnts_sugar`, S, distances, alpha, rho, max_iterations, verbose)
}

#' Get fitness from tour
#' @details Get fitness using the tour, m and distance matrix
#' @param \code{Tour} Set of tour's nodes.
#' @param \code{Distances} Distance matrix
#' @return A double value representing the chromosome fitness
#' @export 
tour_fitness_binary <- function(S, distances) {
    .Call(`_mdp_tour_fitness_binary`, S, distances)
}

#' The crossover operator of the MAMDP algorithm 
#' Cross Over between S_a and S_b
#' @param \code{S_a} Parent A
#' @param \code{S_b} Parent B
#' @param \code{distances} Square and symmetric distance matrix 
#' @return A baby 
#' @examples
#' crossover()
crossover <- function(S_a, S_b, distances) {
    .Call(`_mdp_crossover`, S_a, S_b, distances)
}

#' The crossover operator of the MAMDP algorithm 
#' Cross Over between S_a and S_b
#' @param \code{S_a} Parent A
#' @param \code{S_b} Parent B
#' @param \code{distances} Square and symmetric distance matrix 
#' @return A baby 
#' @examples
#' crossover()
crossover_rand <- function(S_a, S_b, distances) {
    .Call(`_mdp_crossover_rand`, S_a, S_b, distances)
}

#' Def. 1  of http://dx.doi.org/10.1016/j.ejor.2013.06.002
#' Distance between to individuals;
#' @details Distance between to individuals: m - sum(S0XS1);
#' @param \code{S0} Individual.
#' @param \code{S1} Individual.
#' @return A int, number of moves to go from one individual to the other.
#' @export 
solutions_distance <- function(S0, S1) {
    .Call(`_mdp_solutions_distance`, S0, S1)
}

#' Def. 2  of http://dx.doi.org/10.1016/j.ejor.2013.06.002
#' Distance between a individual and a population;
#' @details Distance between to individuals in population: min(m - sum(S0XS), S in Population);
#' @param \code{S0} Individual.
#' @param \code{Population} Target Population.
#' @return A int, min distance between a indivitual and a population.
#' @export 
solution_to_population_distance <- function(S0, population, tour_size) {
    .Call(`_mdp_solution_to_population_distance`, S0, population, tour_size)
}

#' Def. 2  of http://dx.doi.org/10.1016/j.ejor.2013.06.002
#' Distance between a individual and a population;
#' Distance between a individual and a population by index;
#' @details Distance between to individuals in population: min(m - sum(S0XS), S in Population);
#' @param \code{S0} Individual.
#' @param \code{Population} Target Population.
#' @return A int, min distance between a indivitual and a population.
#' @export 
index_to_population_distance <- function(idx, population) {
    .Call(`_mdp_index_to_population_distance`, idx, population)
}

#' Tabu search in a random solution
#' @details generate a random solution, apply tabu search and return the new solution and its fitness
#' @param \code{distances} Distance matrix
#' @param \code{tour_size} You know!
#' @param \code{alpha} You know!
#' @param \code{rho} You know!
#' @param \code{max_iteration} You know!
#' @return List with solution and its fitness
#' @export
tabu_solution_rand <- function(distances, tour_size, alpha = 15L, rho = 1, max_iterations = 50000L) {
    .Call(`_mdp_tabu_solution_rand`, distances, tour_size, alpha, rho, max_iterations)
}

#' MAMDP population update
#' Algorithm 4. Update population strategy of the MAMDP algorithm
#' Ref: http://dx.doi.org/10.1016/j.ejor.2013.06.002
#' @param \code{S} population candidate
#' @param \code{Population} population to be updated
#' @return New population 
#' @examples
#' updatePopulation()
update_population_mamdp <- function(S, population, fitness, distances, beta = 0.6) {
    .Call(`_mdp_update_population_mamdp`, S, population, fitness, distances, beta)
}

#' Pool initialization for MAMDP
#' Section 2.2 of http://dx.doi.org/10.1016/j.ejor.2013.06.002
#' @details Get the initial populatio
#' @param \code{tourSize} Ok. Stop it.
#' @param \code{Distances} Distance matrix
#' @param \code{populationSize} You know!
#' @return A matrix where each column is a individual in the population
#' @export
initialize_population_mamdp <- function(distances, tour_size, population_size = 10L, tabu_max_iterations = 50000L, tabu_multiplier = 3L, tabu_rho = 1, tabu_alpha = 15L) {
    .Call(`_mdp_initialize_population_mamdp`, distances, tour_size, population_size, tabu_max_iterations, tabu_multiplier, tabu_rho, tabu_alpha)
}

